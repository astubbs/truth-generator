package com.google.common.truth.extension.generator.testModel;

import com.google.common.truth.Subject;
import javax.annotation.processing.Generated;
import com.google.common.truth.FailureMetadata;
import com.google.common.truth.IntegerSubject;
import static com.google.common.truth.Fact.*;
import static com.google.common.truth.extension.generator.testModel.MyEmployeeSubject.myEmployees;
import com.google.common.truth.extension.generator.testModel.MyEmployeeSubject;
import com.google.common.truth.extension.generator.testModel.MyEmployee.State;
import static com.google.common.truth.extension.generator.testModel.StateSubject.states;
import com.google.common.truth.extension.generator.testModel.StateSubject;
import java.util.Optional;
import java.time.ZonedDateTime;
import static com.google.common.truth.extension.generator.shaded.java.time.ZonedDateTimeSubject.zonedDateTimes;
import static com.google.common.truth.extension.generator.shaded.java.time.ZonedDateTimeSubject.zonedDateTimes;
import java.util.UUID;
import static com.google.common.truth.extension.generator.UUIDSubject.uUIDs;
import com.google.common.truth.extension.generator.UUIDSubject;
import com.google.common.truth.StringSubject;
import com.google.common.truth.LongSubject;
import java.util.List;
import com.google.common.truth.IterableSubject;
import java.util.Map;
import com.google.common.truth.MapSubject;
import com.google.common.truth.BooleanSubject;
import com.google.common.truth.extension.generator.shaded.java.time.ZonedDateTimeSubject;
import static com.google.common.truth.extension.generator.testModel.IdCardSubject.idCards;
import com.google.common.truth.extension.generator.testModel.IdCardSubject;

/**
 * Truth Subject for the {@link MyEmployee}.
 *
 * Note that this class is generated / managed, and will change over time. So
 * any changes you might make will be overwritten.
 *
 * @see MyEmployee
 * @see MyEmployeeSubject
 * @see MyEmployeeChildSubject
 */
@Generated("truth-generator")
public class MyEmployeeParentSubject extends Subject {

	protected final MyEmployee actual;

	protected MyEmployeeParentSubject(FailureMetadata failureMetadata,
			com.google.common.truth.extension.generator.testModel.MyEmployee actual) {
		super(failureMetadata, actual);
		this.actual = actual;
	}

	public void hasBirthYearNotEqualTo(int expected) {
		if (!(actual.getBirthYear() == expected)) {
			failWithActual(fact("expected BirthYear NOT to be equal to", expected));
		}
	}

	public void hasBirthYearEqualTo(int expected) {
		if ((actual.getBirthYear() == expected)) {
			failWithActual(fact("expected BirthYear to be equal to", expected));
		}
	}

	public IntegerSubject hasBirthYear() {
		isNotNull();
		return check("getBirthYear").that(actual.getBirthYear());
	}

	public void hasBossNotEqualTo(com.google.common.truth.extension.generator.testModel.MyEmployee expected) {
		if (!(actual.getBoss().equals(expected))) {
			failWithActual(fact("expected Boss NOT to be equal to", expected));
		}
	}

	public void hasBossEqualTo(com.google.common.truth.extension.generator.testModel.MyEmployee expected) {
		if ((actual.getBoss().equals(expected))) {
			failWithActual(fact("expected Boss to be equal to", expected));
		}
	}

	public MyEmployeeSubject hasBoss() {
		isNotNull();
		return check("getBoss").about(myEmployees()).that(actual.getBoss());
	}

	public void hasEmploymentStateNotEqualTo(State expected) {
		if (!(actual.getEmploymentState().equals(expected))) {
			failWithActual(fact("expected EmploymentState NOT to be equal to", expected));
		}
	}

	public void hasEmploymentStateEqualTo(
			com.google.common.truth.extension.generator.testModel.MyEmployee.State expected) {
		if ((actual.getEmploymentState().equals(expected))) {
			failWithActual(fact("expected EmploymentState to be equal to", expected));
		}
	}

	public StateSubject hasEmploymentState() {
		isNotNull();
		return check("getEmploymentState").about(states()).that(actual.getEmploymentState());
	}

	public void hasWeightingNotPresent(Optional expected) {
		if (!actual.getWeighting().isPresent()) {
			failWithActual(simpleFact("expected Weighting NOT to be present"));
		}
	}

	public void hasWeightingPresent(java.util.Optional expected) {
		if (actual.getWeighting().isPresent()) {
			failWithActual(simpleFact("expected Weighting to be present"));
		}
	}

	public void hasWeightingNotEqualTo(java.util.Optional expected) {
		if (!(actual.getWeighting().equals(expected))) {
			failWithActual(fact("expected Weighting NOT to be equal to", expected));
		}
	}

	public void hasWeightingEqualTo(java.util.Optional expected) {
		if ((actual.getWeighting().equals(expected))) {
			failWithActual(fact("expected Weighting to be equal to", expected));
		}
	}

	public void hasAnniversaryNotEqualTo(ZonedDateTime expected) {
		if (!(actual.getAnniversary().equals(expected))) {
			failWithActual(fact("expected Anniversary NOT to be equal to", expected));
		}
	}

	public void hasAnniversaryEqualTo(java.time.ZonedDateTime expected) {
		if ((actual.getAnniversary().equals(expected))) {
			failWithActual(fact("expected Anniversary to be equal to", expected));
		}
	}

	public ZonedDateTimeSubject hasAnniversary() {
		isNotNull();
		return check("getAnniversary").about(zonedDateTimes()).that(actual.getAnniversary());
	}

	public void hasIdNotEqualTo(UUID expected) {
		if (!(actual.getId().equals(expected))) {
			failWithActual(fact("expected Id NOT to be equal to", expected));
		}
	}

	public void hasIdEqualTo(java.util.UUID expected) {
		if ((actual.getId().equals(expected))) {
			failWithActual(fact("expected Id to be equal to", expected));
		}
	}

	public UUIDSubject hasId() {
		isNotNull();
		return check("getId").about(uUIDs()).that(actual.getId());
	}

	public void hasNameNotEqualTo(java.lang.String expected) {
		if (!(actual.getName().equals(expected))) {
			failWithActual(fact("expected Name NOT to be equal to", expected));
		}
	}

	public void hasNameEqualTo(java.lang.String expected) {
		if ((actual.getName().equals(expected))) {
			failWithActual(fact("expected Name to be equal to", expected));
		}
	}

	public StringSubject hasName() {
		isNotNull();
		return check("getName").that(actual.getName());
	}

	public void hasSomeLongAspectNotEqualTo(long expected) {
		if (!(actual.getSomeLongAspect() == expected)) {
			failWithActual(fact("expected SomeLongAspect NOT to be equal to", expected));
		}
	}

	public void hasSomeLongAspectEqualTo(long expected) {
		if ((actual.getSomeLongAspect() == expected)) {
			failWithActual(fact("expected SomeLongAspect to be equal to", expected));
		}
	}

	public LongSubject hasSomeLongAspect() {
		isNotNull();
		return check("getSomeLongAspect").that(actual.getSomeLongAspect());
	}

	public void hasProjectListNotWithElement(java.lang.Object expected) {
		if (!actual.getProjectList().contains(expected)) {
			failWithActual(fact("expected ProjectList NOT to have element", expected));
		}
	}

	public void hasProjectListWithElement(java.lang.Object expected) {
		if (actual.getProjectList().contains(expected)) {
			failWithActual(fact("expected ProjectList to have element", expected));
		}
	}

	public void hasProjectListNotEqualTo(List expected) {
		if (!(actual.getProjectList().equals(expected))) {
			failWithActual(fact("expected ProjectList NOT to be equal to", expected));
		}
	}

	public void hasProjectListEqualTo(java.util.List expected) {
		if ((actual.getProjectList().equals(expected))) {
			failWithActual(fact("expected ProjectList to be equal to", expected));
		}
	}

	public IterableSubject hasProjectList() {
		isNotNull();
		return check("getProjectList").that(actual.getProjectList());
	}

	public void hasProjectMapNotWithKey(java.lang.Object expected) {
		if (!actual.getProjectMap().containsKey(expected)) {
			failWithActual(fact("expected ProjectMap NOT to have key", expected));
		}
	}

	public void hasProjectMapWithKey(java.lang.Object expected) {
		if (actual.getProjectMap().containsKey(expected)) {
			failWithActual(fact("expected ProjectMap to have key", expected));
		}
	}

	public void hasProjectMapNotEqualTo(Map expected) {
		if (!(actual.getProjectMap().equals(expected))) {
			failWithActual(fact("expected ProjectMap NOT to be equal to", expected));
		}
	}

	public void hasProjectMapEqualTo(java.util.Map expected) {
		if ((actual.getProjectMap().equals(expected))) {
			failWithActual(fact("expected ProjectMap to be equal to", expected));
		}
	}

	public MapSubject hasProjectMap() {
		isNotNull();
		return check("getProjectMap").that(actual.getProjectMap());
	}

	public void isEmployed() {
		if (actual.isEmployed()) {
			failWithActual(simpleFact("expected to be Employed"));
		}
	}

	public void isNotEmployed() {
		if (!actual.isEmployed()) {
			failWithActual(simpleFact("expected NOT to be Employed"));
		}
	}

	public BooleanSubject hasEmployed() {
		isNotNull();
		return check("isEmployed").that(actual.isEmployed());
	}

	public void hasBirthdayNotEqualTo(java.time.ZonedDateTime expected) {
		if (!(actual.getBirthday().equals(expected))) {
			failWithActual(fact("expected Birthday NOT to be equal to", expected));
		}
	}

	public void hasBirthdayEqualTo(java.time.ZonedDateTime expected) {
		if ((actual.getBirthday().equals(expected))) {
			failWithActual(fact("expected Birthday to be equal to", expected));
		}
	}

	public ZonedDateTimeSubject hasBirthday() {
		isNotNull();
		return check("getBirthday").about(zonedDateTimes()).that(actual.getBirthday());
	}

	public void hasCardNotEqualTo(com.google.common.truth.extension.generator.testModel.IdCard expected) {
		if (!(actual.getCard().equals(expected))) {
			failWithActual(fact("expected Card NOT to be equal to", expected));
		}
	}

	public void hasCardEqualTo(com.google.common.truth.extension.generator.testModel.IdCard expected) {
		if ((actual.getCard().equals(expected))) {
			failWithActual(fact("expected Card to be equal to", expected));
		}
	}

	public IdCardSubject hasCard() {
		isNotNull();
		return check("getCard").about(idCards()).that(actual.getCard());
	}

	public void isEmployedWrapped() {
		if (actual.isEmployedWrapped()) {
			failWithActual(simpleFact("expected to be EmployedWrapped"));
		}
	}

	public void isNotEmployedWrapped() {
		if (!actual.isEmployedWrapped()) {
			failWithActual(simpleFact("expected NOT to be EmployedWrapped"));
		}
	}

	public BooleanSubject hasEmployedWrapped() {
		isNotNull();
		return check("isEmployedWrapped").that(actual.isEmployedWrapped());
	}
}
